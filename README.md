This directory contains code which uses extensible File System APIs to build a ANTI MALWARE FILE SYSTEM(AMFS). AMFS detects and prevents attempts to read or write bad files. A "bad file" is defined as one that contains at least one known malware (e.g., virus) pattern. The existing "wrapfs" file system was used as the starting point and "THE PASS-THRU" filesystem whose source code was in fs/wrapfs was copied and modified to suit my use case.

											       SOURCE FILES       
											       
All the files are modified and used from the source code of wrapfs provided under fs/wrapfs

1) mypatterns.db - This is the file that is used as a database of malicious patterns against which the virus patterns present in the file are matched. AMFS intercepts the various file operations and protects the user from accessing such infected files.By default, no one can modify the mypatterns.db file.To add/remove/list patterns from the mypatterns.db only IOCTLs are used.

2) amfs/amfsctl.c  - This is the user level code to provide ioctl support for adding/deleting/listing patterns present in the patternDb. The user level code performs the required validations before invoking the IOCTL. I used the following references to learn more about IOCTLS. Appropriate error messages were displayed to the user via perror.

http://tuxthink.blogspot.com/2011/01/creating-ioctl-command.html
http://www.linuxjournal.com/article/6908
http://people.ee.ethz.ch/~arkeller/linux/code/ioctl_user.c
http://people.ee.ethz.ch/~arkeller/linux/code/ioctl.c

2) amfs/amfs.h - This header file is copied from the source code of wrapfs.h and has been modified to include support for a linked list stored in the private field of the superblock(void*) pointer.I have used the default linked list APIs provided by the kernel in <include/list.h>

The amfs_sb_info structure has been modified as follows :
							struct amfs_sb_info {
								struct super_block *lower_sb;
							    struct list_head *first;
								char *pattern_db;
								long version;
								};

The superblock structure now stores additional information like :
	struct list_head *first - The head of the linked list 
	char* pattern_db - The patternDb fileName containing the list of malicious patterns against which the file will be scanned.  
	long version - stores the current version. This provides versioning support as part of the partial fulfillment of the EXTRA CREDITS 2.


3) amfs/file.c - In this file the default amfs functions were modified to provide support to prevent read/write/lookup operations on the malicious files. The following functions were modified :
	
	i)   amfs_read()    -    Intercepts the read operations and prevents the user from reading malicious content.
	ii)  amfs_write()   -   Intercepts the write operations and prevents the user from writing malicious content in the files. 
	iii) amfs_readdir() - Function was modified to prevent lookup on infected files. The amfs_filldir() is not provided bydefault 	 				       in wrapfs. The amfs_filldir() function was copied from ecrypts_filldir() to prevent the ls lookup of the 					  infected files. The amfs_lookup_structure was also modified to enable the above feature.
	iv) amfs_unlocked_ioctl() - provides support for addition/removal/listing of patterns from the patternDB.

4) amfs/main.c - amfs_read_super() and amfs_mount() functions were modified to provide instantiate the default options of the superblock and also to parse the mount options specified at runtime. 

5) amfs/Makefile - This file has to be used to build the kernel code for AMFS.

6) amfs/super.c - Gives us the option to modify the attributes and plugin functions of the superblock. This file was used to provide the kernel options for unmount.

7) amfs/amfsctl_header.h - this header file contains the code to provide support for ADD_IOCTL,REMOVE_IOCTL,LIST_IOCTL commands.

8) amfs/Makefile : 
			
			This file contains commands for compiling the user level code using gcc and making the loadable kernel module. This file contains the comprehensive list of all the programs that need to be compiled for execution. Once the "make" command is issued from the command line it automatically compiles all the static kernel code, loadable kernel module and the user-level program all at once. 

9) kernel.config :
			
			I have tried to minimize the kernel configuration to suit my requirements. I have tried to add the support for AMFS and WRAPS Filesystems by adding an entry for AMFS filesystem in the fs/Kconfig and kernel.config.


						   Steps to be followed to compile and execute the project      

For compiling the code 
 
Go to the folder fs/amfs

1) Use the Makefile provided to compile the C source code. A list of source files will be generated from the code.

2) 	Insert the modules for AMFS generated in the above step :
	insmod amfs.ko

3) Mounting the file system and parsing the file options, I have taken the example given HW2 as the baseline,
		
							mount -t amfs -o pattdb=/mypatterns.db /some/lower/path /mnt/amfs 

   I will be allowing the filesystem to be mounted based on the above options:

Mount command is parsed/validated for the following edge cases: 
	i)  If the user specifies an empty filename, then the mount operation is not allowed.
	ii) If the user does not specify pattdb option , then the mount operation is not allowed.
	iii)If the user does not specify the "=" option, the also the mount operation is not allowed.
	iv) Not providing the valid option or not specifing the options are also appropriately handled.

4) Unmounting the file system:
   	umount ../mnt

5) Removing module for AMFS:
	rmmod amfs.ko


										   Executing the User Application   
										   
The following is the way to invoke the system call from the user space :

		Usage   : ./amfsctl {-l|-a|-r} pattern [-h HELP] mount_point_of_AMFS 
	    {-l}    : Use this option to specify when you want to list the patterns from patternDb
	    {-a}    : Use this option to specify when you want to add a pattern to the patternDb
	    {-r}    : Use this option to specify when you want to remove a pattern from patternDb
	    pattern : pattern to be added/removed
	    [-h]    : Used to display the help message to outline the process on how to use the ioctl
	   mount_point_of_AMFS : the point where the AMFS is mounted 

	   		  				  FUNCTIONAL DESIGN ISSUES AND CONSIDERATIONS 	
									
Since this was a more open-ended assignment than HW1, I had to face a lot of design decisions. Some of them are listed below :

1) Approach for hiding the bad file : The approach I have taken for hiding the bad file is that I am storing some extended attributes(BAD_FLAG = "user.bad") for the file, which will basically help us decide whether the file is bad or not. After careful consideration of the policy of renaming files, I decided to go with the policy of adding extending attributes because the first approach works fine as far as hiding the files from lookup is concerned but fails on the following fronts :

	i)  What if the root user tries to delete the file ? 
		This will work fine in my case as the original still exists with the same name, but will fail in case of renaming files as the original file name will be changed and will be stored with a different name that the root user might not be aware of.
	ii) What if due to changes in the patternDb the file changes state from "good" to "bad" and vice-versa ?
		Since in my approach only the extended attributes of the file define whether the file is good or bad, it can be easily implemented. But , with renaming a significant amount of overhead is involved. For example, for preventing lookup of a bad file, it involves repeated unnecessary renaming of the file. Also, when we try to list the files under a parent directory , the ls grabs the lock. The VFS_RENAME too needs a lock on the parent directory to rename the file. This leads to a situation of deadlock with none of the process able to make any progress.

2) If the user tries to write/read/lookup malicious patterns from the files, then the operations are successfully intercepted and disallowed.

3) If the user tries to write some "good" data into a file that already contain malicious pattern, then I allow it to be written to the disk. Any subsequent attempts to access such a malicious file will be BARRED.

4) In substrings as some characters can be always be added to get the malicious string. I am following the approach of substring comparison and not of exact string comparison,as the latter approach inherently has many drawbacks and will not able to deal with most of the test cases.

5) For hiding the malicious files I am setting the extended attribute of the malicious file("user.bad") and then using the filldir() callback hook for readdir() to hide the malicious files.

6) I am supporting the versioning of the files, and have kept an Extend Attribute("user.version") for the same. If there is no change in the version of the patternDB and the patternDb's version is same as the files' version , then the repeated scanning of the files is skipped.Whenever a new file is created it always marks the version number as 0, scans the file against the list and then updates the version of the file to be same as the superblock's version of the pattdb/list against which it was scanned.

7) Due to addition/removal of patterns from the patternDb , a file may undergo a transition from "good" to "bad" and viceversa. The extended attribute versioning support enables to be efficient with minimal scanning and simplifies this transition.

8) The infected files are not visible on lookup. Also, the infected files cannot be lookedup into or be read content from. They are not accessible for root users too. The only operation that the root user can perform is to delete the file.

9) To protect the patternDb file from deletion by hackers and other users, I have set the mode of the patternDb file to 000 to disallow access to any user other than the root. One way to prevent access to the root user as well was to revoke the write permissions on the parent directory, which was not a choice. There were other ways for checking the root_user_id() and then disabling unlink() for the root user.

													


